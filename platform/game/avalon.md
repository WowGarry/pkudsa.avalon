## 1. 总体架构

对战管理器采用单例模式设计，作为整个系统的中央控制器，负责创建、管理和监控所有对战。每个对战拥有唯一标识符，并在独立线程中运行，确保并发性能和系统稳定性。

## 2. 核心组件

### 2.1 对战管理器（BattleManager）

- **单例设计**：确保系统中只有一个对战管理器实例，统一管理资源和对战流程
- 职责：
  - 分配全局唯一的对战ID
  - 创建和启动对战
  - 维护所有进行中和已完成对战的状态
  - 提供对战状态查询和结果获取功能
  - 管理对战线程的生命周期

### 2.2 裁判系统（Referee）

- 职责：
  - 执行具体对战逻辑和游戏规则
  - 协调各玩家的行动顺序
  - 接收并处理玩家决策
  - 更新和维护游戏状态
  - 判定游戏结束条件和胜负
  - 记录每回合的详细信息

### 2.3 结果记录系统

- 职责：
  - 为每个对战创建专属的结果存储目录
  - 将每回合的状态和行动以JSON格式保存
  - 记录完整的对战过程和最终结果
  - 支持对战回放和数据分析

## 3. 工作流程

### 3.1 对战创建流程

1. 客户端请求创建一个新对战，提供玩家配置和对战参数
2. 对战管理器生成全局唯一的对战ID
3. 创建对战信息记录，包含创建时间、玩家信息和对战配置
4. 返回对战ID给客户端

### 3.2 对战启动流程

1. 客户端使用对战ID请求启动对战
2. 对战管理器验证对战ID并检查状态
3. 创建并启动一个新的裁判线程
4. 更新对战状态为"运行中"
5. 返回启动成功确认

### 3.3 对战执行流程

1. 裁判线程初始化游戏环境和玩家实例
2. 执行游戏回合循环：
   - 向每个玩家提供当前可见的游戏状态
   - 收集每个玩家的决策行动
   - 根据游戏规则执行行动并更新状态
   - 记录本回合的所有行动和状态变化
   - 检查游戏是否结束
3. 游戏结束后，计算最终结果和胜负
4. 保存完整的对战记录和结果
5. 更新对战状态为"已完成"

### 3.4 结果查询流程

1. 客户端使用对战ID请求查询对战状态或结果
2. 对战管理器验证对战ID并返回相应信息
3. 如果对战已完成，提供完整的结果数据
4. 如果对战未完成，提供当前进度和状态

## 4. 数据结构

### 4.1 对战信息

- 对战ID：全局唯一标识符
- 创建时间：对战创建的时间戳
- 玩家信息：包含所有参与者的配置和类信息
- 对战配置：包含游戏规则、地图、回合限制等参数
- 对战状态：已创建、运行中、已完成、失败等
- 结果路径：最终结果文件的存储位置

### 4.2 回合记录

- 回合ID：当前回合的序号
- 玩家行动：每个玩家在当前回合的决策和行动
- 行动结果：每个行动的执行结果和影响
- 回合后状态：本回合结束后的完整游戏状态

### 4.3 最终结果

- 对战基本信息：ID、时间、配置等
- 玩家信息：所有参与者的信息
- 回合记录：所有回合的简要信息
- 胜利者：对战的最终胜利方
- 游戏状态：结束时的游戏状态
- 统计数据：各类游戏数据和统计信息

## 5. 异常处理

- **超时处理**：设置玩家决策的时间限制，超时自动使用默认行动
- **错误处理**：捕获并记录对战过程中的所有异常和错误
- **中断恢复**：支持从特定状态恢复对战（可选功能）
- **资源清理**：确保对战完成或失败后正确释放所有资源

## 6. 扩展设计

- **观察者模式**：支持外部系统订阅对战事件和状态变化 (这里解释了如何传输数据到可视化部分)
- **策略模式**：使裁判系统能够适应不同类型的游戏规则 (这个不急)
- **工厂模式**：动态创建不同类型的玩家实例
- **装饰器模式**：为基本功能添加日志、计时等额外功能

## 7. 可视化支持

- 每个对战产生的JSON格式结果文件设计为直接支持可视化系统使用
- 提供丰富的元数据和时间戳，便于回放和分析
- 支持分步骤查看对战过程，方便调试和展示
- 结果文件包含足够的上下文信息，确保可独立理解